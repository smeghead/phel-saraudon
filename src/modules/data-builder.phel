(ns saraudon\modules\data-builder
  (:require phel\str :as s)
  (:require saraudon\modules\types))

(defstruct temporary-node [path modify-lines])

(defstruct node [id path label modify-lines])

(defstruct link [source target value])

(defstruct data [nodes links])

(defn- unique-node [elements aditionals]
  (loop [elements elements
         aditionals aditionals]
    (if (empty? aditionals)
      elements
      (let [element (first aditionals)
            new? (empty? (find |(if (empty? $)
                                  false
                                  (= ($ :path) (element :path))) elements))]
            # avoid find problem. #737
            #new? (empty? (find |(= ($ :path) (element :path)) elements))]
        (recur (if new?
                 (push elements element)
                 elements)
               (rest aditionals))))))

(defn- get-temprary-nodes [commits]
  (loop [commits commits
         acc []]
    (if (empty? commits)
       acc
#      (loop [t-nodes acc
#             id 0
#             acc2 []]
#        (if (empty? t-nodes)
#          acc2
#          (let [t-node (first t-nodes)
#                path (t-node :path)
#                label (s/replace path "/^.*\/([^\/]*)$/" "$1")]
#            (recur (rest t-nodes) (inc id) (push acc2 (node id path label 0))))))
      (recur (rest commits) (concat acc (map |(temporary-node ($ :path) ($ :modify-lines)) ((first commits) :files)))))))

(defn- search-temporary-nodes [t-nodes node]
  (loop [t-nodes t-nodes
         acc []]
    (if (empty? t-nodes)
      acc
      (let [t-node (first t-nodes)]
        (recur (rest t-nodes) (if (= (t-node :path) (node :path))
                                (push acc t-node)
                                acc))))))

(defn- get-unique-temporary-nodes [t-nodes]
  (loop [nodes t-nodes
         acc []]
    (if (empty? nodes)
      acc
      (let [node (first nodes)
            exists? (find |(if (empty? $)
                             false
                             (= ($ :path) (node :path))) acc)]
        (recur (rest nodes) (if exists?
                              acc
                              (push acc node)))))))

(defn- get-nodes [commits]
  (let [t-nodes (get-temprary-nodes commits)
        unique-temporary-nodes (get-unique-temporary-nodes t-nodes)]
    (loop [nodes unique-temporary-nodes
           id 0
           acc []]
      (if (empty? nodes)
        acc
        (let [t-node (first nodes)
              same-nodes (search-temporary-nodes t-nodes t-node)
              path (t-node :path)
              label (s/replace path "/^.*\/([^\/]*)$/" "$1")
              amount-modify-lines (sum (map |($ :modify-lines) same-nodes))]
          (recur (rest nodes) (inc id) (push acc (node id path label amount-modify-lines))))))))

(defn- unique-link [elements aditionals]
  (loop [elements elements
         aditionals aditionals]
    (if (empty? aditionals)
      elements
      (let [element (first aditionals)
            new? (empty? (find |(if (empty? $)
                                  false
                                  (or (and (= ($ :source) (element :source))
                                           (= ($ :target) (element :target)))
                                      (and (= ($ :source) (element :target))
                                           (= ($ :target) (element :source)))))
                               elements))]
            # avoid find problem. #737
            #new? (empty? (find |(= ($ :id) (element :id)) elements))]
        (recur (if new?
                 (push elements element)
                 elements)
               (rest aditionals))))))

(defn- get-node-index [nodes file]
  (loop [nodes nodes]
    (let [node (first nodes)]
      (if (= (node :path) (file :path))
        (node :id)
        (recur (rest nodes))))))

(defn- get-links [commits nodes]
  (loop [commits commits
         acc []]
    (if (empty? commits)
      acc
      (let [new-links (filter truthy? (for [source :in ((first commits) :files)
                                            target :in ((first commits) :files)]
                                        (if (= (source :path) (target :path))
                                          nil
                                          (link (get-node-index nodes source) (get-node-index nodes target) 1))))]
        (recur (rest commits) (unique-link acc new-links))))))

(defn build [commits]
  (let [nodes (get-nodes commits)
        links (get-links commits nodes)]
    (data nodes links)))
